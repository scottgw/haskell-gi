{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeOperators #-}

module GI.API
    -- ( Named(..)
    -- , Constant(..)
    -- , Arg(..)
    -- , Callable(..)
    -- , Function(..)
    -- , Signal(..)
    -- , Property(..)
    -- , Field(..)
    -- , Struct(..)
    -- , Callback(..)
    -- , Interface(..)
    -- , Object(..)
    -- , Enumeration(..)
    -- , Flags (..)
    -- , Union (..)
    -- , loadNamespace
    -- , NameSpace (..)
    -- , 
    -- )
    where

import Data.List (intercalate, foldl')
import Data.Word
import Data.Label
import qualified Data.Map as Map
import Data.Map (Map)

import GI.Internal.Types
import GI.Internal.ArgInfo
import GI.Internal.BaseInfo
import GI.Internal.CallableInfo
import GI.Internal.ConstantInfo
import GI.Internal.EnumInfo
import GI.Internal.FieldInfo
import GI.Internal.FunctionInfo
import GI.Internal.InterfaceInfo
import GI.Internal.ObjectInfo
import GI.Internal.PropertyInfo
import GI.Internal.StructInfo
import GI.Internal.Typelib (getInfos, load)
import GI.Internal.UnionInfo
import GI.Type
import GI.Value

-- orphaned instances from autogenerated code
instance Show Direction where
    show DirectionIn = "in"
    show DirectionOut = "out"
    show DirectionInout = "in/out"

instance Show Scope where
    show ScopeTypeInvalid = "invalid"
    show ScopeTypeCall = "call"
    show ScopeTypeAsync = "async"
    show ScopeTypeNotified = "notified"

instance Show Transfer where
    show TransferNothing = "notrans"
    show TransferContainer = "contain"
    show TransferEverything = "everything"

shortScope ScopeTypeInvalid = ""
shortScope s = show s

shortTrans TransferNothing = ""
shortTrans t = show t

data Named a = 
  Named 
  { nameSpace :: String
  , nameName :: String
  , nameNamed :: a 
  } deriving (Ord, Eq)


instance Show a => Show (Named a) where
    show (Named ns n a) = ns ++ "." ++ n ++ " " ++ show a

toNamed :: BaseInfoClass bi => bi -> a -> Named a
toNamed bi x =
   let namespace = baseInfoNamespace $ baseInfo bi
       name = baseInfoName $ baseInfo bi
    in Named namespace name x

data Constant = Constant {
    constValue :: Value }
    deriving (Ord, Eq, Show)

toConstant :: ConstantInfo -> Named Constant
toConstant ci =
    let typeInfo = constantInfoType ci
        arg = constantInfoValue ci
        value = fromArgument typeInfo arg
     in toNamed ci $ Constant value

data Enumeration = Enumeration {
    enumValues :: [(String, Word64)] } 
                 deriving (Show, Ord, Eq)

toEnumeration :: EnumInfo -> Named Enumeration
toEnumeration ei = toNamed ei $ Enumeration $
    (map (\vi -> (baseInfoName . baseInfo $ vi, valueInfoValue vi))
        (enumInfoValues ei))

data Flags = Flags Enumeration
    deriving (Show, Eq, Ord)

toFlags :: EnumInfo -> Named Flags
toFlags ei = let Named ns n x = toEnumeration ei
              in Named ns n (Flags x)

data Arg = Arg {
    argName ::String,
    argType :: Type,
    direction :: Direction,
    scope :: Scope,
    transfer :: Transfer } deriving (Ord, Eq)

instance Show Arg where
    show (Arg aName aType dir sc trans) =
        show dir ++ " " ++ aName ++ " :: " ++ show aType ++ 
        shortScope sc ++ " " ++ shortTrans trans

toArg :: ArgInfo -> Arg
toArg ai =
   Arg (baseInfoName . baseInfo $ ai)
        (typeFromTypeInfo . argInfoType $ ai)
        (argInfoDirection ai)
        (argInfoScope ai)
        (argInfoOwnershipTransfer ai)

data Callable = Callable {
    returnType :: Type,
    returnMayBeNull :: Bool,
    returnTransfer :: Transfer,
    returnAttributes :: [(String, String)],
    callArgs :: [Arg] } deriving (Ord, Eq)

instance Show Callable where
    show (Callable retType mayNull trans attrs argus) =
        let nulMark = if mayNull then "?" else ""
            attrsStr = if null attrs then "" else show attrs
        in
          "(" ++ intercalate "," (map show argus) ++ ")" ++
          " :: " ++ show retType ++ nulMark ++ 
          "\n" ++ shortTrans trans ++ ", " ++ attrsStr
       
toCallable :: CallableInfo -> Named Callable
toCallable ci =
    let returnType = callableInfoReturnType ci
        argType = typeFromTypeInfo returnType
        ais = callableInfoArgs ci
        in toNamed ci $ Callable argType
               (callableInfoMayReturnNull ci)
               (callableInfoCallerOwns ci)
               (callableInfoReturnAttributes ci)
               (map toArg ais)

data Function = Function {
    fnSymbol :: String,
    fnFlags :: [FunctionInfoFlag],
    fnCallable :: Named Callable } deriving (Eq, Ord)

instance Show FunctionInfoFlag where
    show FunctionIsMethod = "method"
    show FunctionIsConstructor = "constructor"
    show _ = "SomeFuncInfo"

instance Show Function where
    show (Function symb flags callable) =
        "func " ++ symb ++ " " ++ show flags ++ " " ++ show callable

toFunction :: FunctionInfo -> Function
toFunction fi =
     let ci = fromBaseInfo (baseInfo fi) :: CallableInfo
     in Function (functionInfoSymbol fi) 
                 (functionInfoFlags fi) 
                 (toCallable ci)

toNamedFunction fi = toNamed (baseInfo fi) (toFunction fi)


data Signal = Signal
    deriving Show

toSignal :: SignalInfo -> Signal
toSignal _si = error "fixme"

data Property = Property {
    propName :: String,
    propType :: Type,
    propFlags :: [ParamFlag] } deriving (Eq, Ord)

instance Show Property where
    show (Property prName prType prFlags) =
        prName ++ " :: " ++ show prType ++ " " ++ show prFlags

toProperty :: PropertyInfo -> Property
toProperty pi =
    Property (baseInfoName $ baseInfo pi)
        (typeFromTypeInfo $ propertyInfoType pi)
        (propertyInfoFlags pi)

data Field = Field {
    fieldName :: String,
    fieldType :: Either Type Function,
    fieldFlags :: [FieldInfoFlag] } deriving (Eq, Ord)

instance Show Field where
    show (Field fName fType fFlags) =
        "field " ++ fName ++ " :: " ++ show fType ++ show fFlags

toField :: FieldInfo -> Field
toField fi =
    Field (baseInfoName . baseInfo $ fi)
          (either (Left . id) (Right . toFunction) (typeFromTypeInfoOrFunc $ fieldInfoType fi))
          (fieldInfoFlags fi)

data Struct = 
  Struct 
  { fields :: [Field]
  , structMethods :: [Function]
  }
  deriving (Ord, Eq, Show)

toStruct :: StructInfo -> Named Struct
toStruct si = toNamed si $ Struct (map toField $ structInfoFields si)
                                  (map toFunction $ structInfoMethods si)

-- XXX: Capture alignment and method info.

data Union = Union {
    unionFields :: [Field] }
    deriving (Show, Eq, Ord)

toUnion :: UnionInfo -> Named Union
toUnion ui =
    toNamed ui $ Union (map toField $ unionInfoFields ui)

data Callback = Callback (Named Callable)
    deriving Show

data Interface = Interface {
    ifMethods :: [Function],
    ifConstants :: [Named Constant],
    ifProperties :: [Property] }
    deriving (Show, Eq, Ord)

toInterface :: InterfaceInfo -> Named Interface
toInterface ii =
    toNamed ii $ Interface
        (map toFunction $ interfaceInfoMethods $ ii)
        (map toConstant $ interfaceInfoConstants $ ii)
        (map toProperty $ interfaceInfoProperties $ ii)

data Object = Object {
    objName :: String,
    objParent :: Maybe (Named Object),
    objFields :: [Field],
    objMethods :: [Function],
    -- objSignals :: [Signal],
    objProperties :: [Property] } deriving (Eq, Ord)

instance Show Object where
    show (Object name parent fields methods properties) =
        unlines $ 
          [name
          , maybe "" (\o -> " inherits " ++ objName (nameNamed o)) parent
          , "{"] ++ 
          map show fields ++
          map show methods ++ 
          map show properties ++
          ["}"]
                

toObject :: ObjectInfo -> Named Object
toObject oi =
    toNamed oi $ Object
        (objectInfoName oi)
        (fmap toObject $ objectInfoParent oi)
        (map toField $ objectInfoFields oi)
        (map toFunction $ objectInfoMethods oi)
        (map toProperty $ objectInfoProperties oi)

type NamedMap a = Map String a

data Namespace = 
  Namespace
  { _nsName   :: String
  , _nsObject :: NamedMap Object
  , _nsEnum   :: NamedMap Enumeration
  , _nsConst  :: NamedMap Constant
  , _nsUnion  :: NamedMap Union
  , _nsStruct :: NamedMap Struct
  , _nsFlags  :: NamedMap Flags
  , _nsFunc   :: NamedMap Function
  , _nsCB     :: NamedMap Callable
  , _nsIFace  :: NamedMap Interface
  }

mkNamespace name = 
  Namespace 
  { _nsName   = name
  , _nsObject = Map.empty
  , _nsEnum   = Map.empty
  , _nsConst  = Map.empty
  , _nsUnion  = Map.empty
  , _nsStruct = Map.empty
  , _nsFlags  = Map.empty
  , _nsFunc   = Map.empty
  , _nsCB     = Map.empty
  , _nsIFace  = Map.empty
  }

mkLabels [''Namespace]

class HasName a where
  nameOf :: a -> String

insertNamed :: Ord a => Named a -> NamedMap a -> NamedMap a
insertNamed x = Map.insert (nameName x) (nameNamed x)

nsInsert :: Ord a 
            => (Namespace :-> NamedMap a) 
            -> Named a 
            -> Namespace 
            -> Namespace
nsInsert sel x ns = modify sel (insertNamed x) ns

nsAddObject = nsInsert nsObject
nsAddEnum   = nsInsert nsEnum
nsAddConst  = nsInsert nsConst
nsAddUnion  = nsInsert nsUnion
nsAddStruct = nsInsert nsStruct
nsAddFlags  = nsInsert nsFlags
nsAddFunc   = nsInsert nsFunc
nsAddCB     = nsInsert nsCB
nsAddIFace  = nsInsert nsIFace

toNamespace :: BaseInfoClass bi => bi -> Namespace -> Namespace
toNamespace i = toInfo' (baseInfoType i) (baseInfo i)
  where
    toInfo' InfoTypeConstant = nsAddConst  . toConstant      . fromBaseInfo
    toInfo' InfoTypeEnum     = nsAddEnum   . toEnumeration   . fromBaseInfo
    toInfo' InfoTypeFlags    = nsAddFlags  . toFlags         . fromBaseInfo
    toInfo' InfoTypeFunction = nsAddFunc   . toNamedFunction . fromBaseInfo
    toInfo' InfoTypeCallback = nsAddCB     . toCallable      . fromBaseInfo
    toInfo' InfoTypeStruct   = nsAddStruct . toStruct        . fromBaseInfo
    toInfo' InfoTypeUnion    = nsAddUnion  . toUnion         . fromBaseInfo
    toInfo' InfoTypeObject   = nsAddObject . toObject        . fromBaseInfo
    toInfo' InfoTypeInterface = nsAddIFace . toInterface     . fromBaseInfo
    toInfo' it = error $ "not expecting a " ++ show it


loadNamespace :: String -> Maybe String -> IO Namespace
loadNamespace name versionMb = do
    lib <- load name versionMb
    infos <- getInfos lib
    -- XXX: Work out what to do with boxed types.
    let
      infos' = filter (\i -> baseInfoType i /= InfoTypeBoxed) infos
      ns = foldl' (flip toNamespace) (mkNamespace name) infos'
    return ns
